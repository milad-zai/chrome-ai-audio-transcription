/* eslint-disable @typescript-eslint/ban-ts-comment */
//disable type checking
// @ts-nocheck

import { useState } from "react";
import "./App.css";

function App() {
  const [isCapturing, setIsCapturing] = useState(false);

  function setupMediaRecorder() {
    console.log("Setting up media recorder");

    // Initialize MediaRecorder with the audio stream
    mediaRecorder = new MediaRecorder(audioStream, { mimeType: "audio/webm" });

    mediaRecorder.ondataavailable = (event) => {
      if (event.data.size > 0) {
        chunks.push(event.data);
        sendAudioChunkToServer(event.data);
      }
    };

    mediaRecorder.onstop = () => {
      audioStream.getTracks().forEach((track) => track.stop());
      audioStream = null;
    };

    mediaRecorder.start(1000); // Collect audio data in 1-second chunks
  }

  function stopCapture() {
    console.log("Stopping capture");
    if (mediaRecorder) {
      mediaRecorder.stop();
    }
    if (audioStream) {
      audioStream = null;
    }
  }

  // Sends audio chunk to the transcription server for processing
  async function sendAudioChunkToServer(audioBlob) {
    console.log("Sending audio chunk to server");

    const formData = new FormData();
    formData.append("audio", audioBlob, "audio.webm");

    try {
      const response = await fetch(TRANSCRIPTION_API_URL, {
        method: "POST",
        body: formData,
      });
      const data = await response.json();

      console.log("Response from server:", data);

      if (data && data.transcription) {
        console.log("Transcription:", data.transcription);
      }
    } catch (error) {
      console.error("Error sending audio chunk:", error);
    }
  }

  function onError(error: Error) {
    console.error(`Error: ${error}`);
  }

  function sendMessageToTabs(tabs: chrome.tabs.Tab[]) {
    for (const tab of tabs) {
      chrome.tabs
        .sendMessage(tab.id!, { action: "startCapture" })
        .then((response) => {
          console.log("Message from the content script:");
          console.log(response.response);
        })
        .catch(onError);
    }
  }
  const handleCaptureToggle = async () => {
    if (isCapturing) {
      chrome.runtime.sendMessage({ action: "stopCapture" });
      //console.log("Stopping capture");
    } else {
      //try to use popup and load chats in background and display somewhere...

      chrome.tabs
        .query({
          currentWindow: true,
          active: true,
        })
        .then(sendMessageToTabs)
        .catch(onError);

      /* try {
        // Request screen capture with both video and audio
        const stream = await navigator.mediaDevices.getDisplayMedia({
          video: true, // Required, even if we don't use the video
          audio: true, // This will capture the audio from the screen
        });
        console.log("Stream captured", stream);
      } catch (error) {
        console.error("Error capturing audio:", error);
      } */
      //chrome.runtime.sendMessage({ action: "startCapture" });
      //console.log("Starting capture");
      /* chrome.tabs
        .query({
          active: true,
          currentWindow: true,
        })
        .then((tabs) => {
          console.log("tabs", tabs);
          chrome.tabCapture.capture({ audio: true, video: false }, (stream) => {
            if (chrome.runtime.lastError || !stream) {
              console.error("Error capturing audio:", chrome.runtime.lastError);
              return;
            }

            console.log("Stream captured", stream);

            try {
              const output = new AudioContext();
              const source = output.createMediaStreamSource(stream);
              source.connect(output.destination);
            } catch (error) {
              console.error("Error creating audio context:", error);
            }

            chrome.runtime.sendMessage({
              action: "startCapture",
              stream: stream,
            });
          });
        }); */
      /* const [tab] = await chrome.tabs.query({
        active: true,
        currentWindow: true,
      });
      console.log(tab);
      const tabId = tab.id;
      let streamId; */
      /* chrome.tabCapture.getMediaStreamId(
        {
          targetTabId: tabId,
        },
        (id) => (streamId = id)
      ); */
      /* const media = await navigator.mediaDevices.getUserMedia({
        audio: {
          // @ts-expect-error: Unreachable code error
          mandatory: {
            chromeMediaSource: "tab",
            chromeMediaSourceId: streamId,
          },
        },
      });
      console.log("media", media); */
      /* let tabId: number;
      chrome.tabs.query({ active: true, currentWindow: true }, (tabs) => {
        console.log("tabs", tabs);
        tabId = tabs[0].id!;

        chrome.tabCapture.getCapturedTabs((ci) => {
          console.log("ci", ci);
          if (!ci.some((e) => e.tabId == tabId)) {
            chrome.tabCapture.getMediaStreamId(
              { consumerTabId: tabId },
              (streamId) => {
                chrome.runtime.sendMessage({
                  action: "startCapture",
                  streamId: streamId,
                });
                console.log("Stream id", streamId);
              }
            );
          }
        });
      }); */
      /* chrome.tabCapture.getMediaStreamId(
        { audio: true, video: false },
        (id) => {
          console.log("Stream id", id);
        }
      ); */
      /* chrome.tabCapture.getMediaStreamId({ targetTabId: tabId }, async (id) => {
        const media = await navigator.mediaDevices.getUserMedia({
          audio: {
            mandatory: {
              chromeMediaSource: "tab",
              chromeMediaSourceId: id,
            },
          }
        });

        // Continue to play the captured audio to the user.
        const output = new AudioContext();
        const source = output.createMediaStreamSource(media);
        source.connect(output.destination);
      }); */
    }
    setIsCapturing(!isCapturing);
  };

  return (
    <div style={{ padding: "20px", textAlign: "center" }}>
      <h1>Audio Stream Capture</h1>
      <button onClick={handleCaptureToggle}>
        {isCapturing ? "Stop Capture" : "Start Capture"}
      </button>
    </div>
  );
}

export default App;
